from Crypto.Util.number import bytes_to_long, long_to_bytes

def euc(a, b):  
    if a == 0 :   
        return 0,1
             
    x1 ,y1 = euc(b%a, a) 
     
    x = y1 - (b//a) * x1
    y = x1  
     
    return x, y 

def tot(p, q):
	return (p - 1) * (q - 1)

# Big e could potentially generate small d, potential Wiener attack
p = 24328018640794723474049568328277606512735157580657498241497896109573317533020664926876959270979419294379862831519267190579243752117004014273749380769891617
q = 33403801776291755784656688828895586428507621726361062851694110338943038036766412050403906389726931603470679901391544684076182000342984311917615170506000599

n = p*q
e = 157723339029907115318529749302666563945325669944327406327452104900581103254737172340018405805525813771295680942222866585260736416396338080085629849367387913930447325905535899797842413479277550778249126247601247362913772097547248197348719745359809871927417705675983075728816554011109514136908620365979914462853

def enc(plaintext):
    plainlong = bytes_to_long(plaintext.encode())
    cipher = pow(plainlong, e, n)

    return cipher

def dec(cipher):
    d = euc(tot(p, q), e)[1]

    plainlong = pow(cipher, d, n)
    return long_to_bytes(plainlong)